#! /bin/sh -f
#\
mkdir -p logfiles
#\
exec tessent -shell -log logfiles/$0.log -replace -dofile "$0"

set PDK_ROOT ../../tech
set design_name croc_chip 

# Set the context to insert DFT into RTL-level design
# Define a new design ID
set_context dft -rtl -design_id rtl2

# Set the location of the TSDB. Default is the current working directory.
set_tsdb_output_directory ../tsdb_outdir

# No need to read in the design using read_verilog. It can be read directly from the TSDB.
read_design ${design_name} -design_id rtl1

# Read the cell library
read_cell_library ${PDK_ROOT}/tessent/ihp-sg13g2_stdcell.tcelllib
read_cell_library ${PDK_ROOT}/tessent/ihp-sg13g2_io.tcelllib

# Define location of memory library files
set_design_sources -format tcd_memory -Y ${PDK_ROOT}/tessent/memories -extension tcd_memory

# Read memory verilog model
read_verilog ${PDK_ROOT}/ihp-sg13g2/libs.ref/sg13g2_sram/t-verilog/*.v -exclude_from_file_dictionary -interface_only
# Read the verilog

set_current_design ${design_name}

# The design level is already specified in first pass and no need to specify it again

# Add DFT Signals
# DFT Signal used for logic test
add_dft_signals ltest_en
# When design_level is chip, the source node needs to exist in the design and the tool cannot create it as a port
# Reusing pdata_p[1], pdata_p[0], enable_p as scan_en, edt_update and test_clock
add_dft_signals scan_en edt_update test_clock -source_node { unused0_i  unused1_i unused2_i }
# Create shift_capture_clock and edt_clock as gated versions of test_clock
add_dft_signals shift_capture_clock edt_clock -create_from_other_signals
# DFT Signal used by top-level EDT
add_dft_signals edt_mode
# DFT Signal used for BoundaryScan to be used with logic test without contacting inputs
add_dft_signals int_ltest_en output_pad_disable
# DFT Signal used for Scan Tested Instruments like memorybist/boundary scan
add_dft_signals tck_occ_en
# DFT Signal used to bypass memories or to run multi-load ATPG for memories
add_dft_signals memory_bypass_en

# Use ltest_en to connect to AuxEn of the EDT Channel in/out pins
add_dft_control_points [get_auxiliary_pins unused3_i -enable -direction input] -dft_signal_source_name ltest_en
add_dft_control_points [get_auxiliary_pins unused4_i -enable -direction input] -dft_signal_source_name ltest_en
add_dft_control_points [get_auxiliary_pins unused5_i -enable -direction input] -dft_signal_source_name ltest_en
add_dft_control_points [get_auxiliary_pins unused4_o -enable -direction output] -dft_signal_source_name ltest_en
add_dft_control_points [get_auxiliary_pins unused5_o -enable -direction output] -dft_signal_source_name ltest_en
add_dft_control_points [get_auxiliary_pins unused6_o -enable -direction output] -dft_signal_source_name ltest_en

# Specify pre-DFT DRC rules
set_dft_specification_requirements -logic_test on
add_clocks jtag_tck_i -period 100ns

check_design_rules

# Create and report a DFT Specification
# Empty DFT specification for OCC and EDT are created here and populated later in this dofile
set spec [create_dft_specification -sri_sib_list {occ edt} ]
report_config_data $spec

read_config_data -in $spec -from_string {
  OCC {
    ijtag_host_interface : Sib(occ);
  }
}

# Below is a generic way to populate the OCC. The clock list is design-specific and needs to be updated for the design
# The scan_enable and shift_capture_clock signals are automatically connected to OCC instances
# Modify the below list for your specific design requirements
set id_clk_list [list \
  clk2 jtag_tck_i \
  clk_i clk_i \
]
foreach {id clk} $id_clk_list {
  set occ [add_config_element OCC/Controller($id) -in $spec]
  set_config_value clock_intercept_node -in $occ $clk
}
report_config_data $spec

# The edt_clock and edt_update signals are automatically connected to EDT instances
# The EDT controller is built with Bypass
# Modify the below specification for your specific design requirements
# The propery connect_bscan_segments_to_lsb_chains defaults to auto and connects the divided boundary scan segments from the previous pass to EDT
read_config_data -in $spec -from_string {
   EDT {
     ijtag_host_interface : Sib(edt);
       Controller (c1) {
         longest_chain_range : 65, 100;
         scan_chain_count : 100;
         input_channel_count : 3;
         output_channel_count : 3;
          Connections +{
            EdtChannelsIn(1) {
            }
            EdtChannelsIn(2) {
            }
            EdtChannelsIn(3) {
            }
            EdtChannelsOut(1) {
            }
            EdtChannelsOut(2) {
            }
            EdtChannelsOut(3) {
            }
          }
       }
    }
}
# The EDT Channel In/Out pins which are equipped with auxiliary ports from the previous pass insertion need to be specified
set_config_value port_pin_name \
-in $spec/EDT/Controller(c1)/Connections/EdtChannelsIn(1) [get_single_name [get_auxiliary_pins unused3_i -direction input]]
set_config_value port_pin_name \
-in $spec/EDT/Controller(c1)/Connections/EdtChannelsIn(2) [get_single_name [get_auxiliary_pins unused4_i -direction input]]
set_config_value port_pin_name \
-in $spec/EDT/Controller(c1)/Connections/EdtChannelsIn(3) [get_single_name [get_auxiliary_pins unused5_i -direction input]]
set_config_value port_pin_name \
-in $spec/EDT/Controller(c1)/Connections/EdtChannelsOut(1) [get_single_name [get_auxiliary_pins unused4_o -direction output] ]
set_config_value port_pin_name \
-in $spec/EDT/Controller(c1)/Connections/EdtChannelsOut(2) [get_single_name [get_auxiliary_pins unused5_o -direction output] ]
set_config_value port_pin_name \
-in $spec/EDT/Controller(c1)/Connections/EdtChannelsOut(3) [get_single_name [get_auxiliary_pins unused6_o -direction output] ]


report_config_data $spec
#display_spec

# Generate and insert the hardware
process_dft_specification

# Extract IJAG network and create ICL file for the design
extract_icl

# Creates a Synthesis script of ALL the RTL (orignial and newly-created) to be used in DC Shell in next Step
write_design_import_script -use_relative_path_to . for_dc_synthesis_edt_occ.tcl -replace

# Generate patterns to verify the inserted DFT logic
create_pattern_specification
process_pattern_specification

# Point to the libraries and run the simulation 
set_simulation_library_sources -v ${PDK_ROOT}/ihp-sg13g2/libs.ref/sg13g2_stdcell/verilog/sg13g2_stdcell.v -v ${PDK_ROOT}/ihp-sg13g2/libs.ref/sg13g2_io/verilog/sg13g2_io.v -v ${PDK_ROOT}/ihp-sg13g2/libs.ref/sg13g2_sram/t-verilog/*.v 
run_testbench_simulations

# If simulation fails, use this command to see which pattern failed
#check_testbench_simulations

exit
